\documentclass[12pt]{article}
\usepackage{csvsimple}
\usepackage{fullpage}
\begin{document}
\title{A brute-force method for finding lower bounds on finding triangles using NAND gates}
\author{Josh Burdick}
\maketitle

Here, I look at the complexity of checking whether an undirected
graph contains a triangle (a.k.a. 3-clique, or $K_3$).
This is a tiny case of the NP-complete
CLIQUE problem. We would therefore expect it to be both hard to answer, and also difficult
to {\em prove} hard to answer.

Previously, I wrote up an attempt at a proof that
finding triangles in 6-input graphs requires
${6 \choose 3} + 1 = 21$ NAND gates.
The proof has not been thoroughly checked (much less
published), but I believe it to be correct.
I tried pushing the same methods to get a proof for the
$n=7$ case, but they didn't seem to be going much higher
than ``slightly more than the number of inputs.'' 
This is probably not surprising to anyone (at least,
I am not surprised.)

Therefore, I decided to look for other methods, which
might get further, or at least require less thinking.
I first tried encoding the problem
as a quantified Boolean formula, and finding solutions
using a BDD solver. Since that was using a ton of memory,
I then tried looking for circuits which only {\em approximately}
find triangles.

\subsection{Motivation}

Why might bounds on circuits for tiny graphs be useful? Since we're
only looking at tiny input graphs (and circuits), such bounds have
limited relevance to the $P=NP$ question.

It seems natural to guess that ``you need at least one NAND gate per triangle'',
and try to prove that.
If brute-force search turned up a circuit with even one fewer NAND gate
than there are triangles,
then that would rule out that proof strategy.
The structure of the circuit might be interesting (even though it wouldn't
say anything directly about whether $P=NP$).

The encoded formulas may also be useful as test problems for SAT solvers.
Benchmarks and competitions for those often require a source of
problems known to be unsatisfiable, and/or difficult \cite{toughsat}.
 Assuming $P \ne NP$,
a formula corresponding to the existence of a small circuit for an NP-complete
problem should be unsatisfiable. (To save memory, we relax the requirement
that the circuit work on all possible inputs; this means that the formula we
write may be satisfiable, even if no circuit with that many gates {\em exactly}
finds triangles.)

Note that this is somewhat win-win: either the generated formulas are easy to
prove unsatisfiable (in which case we get better lower bounds on triangle finding),
or they're hard to prove unsatisfiable (in which case we have more probably-unsatisfiable
problems for testing SAT solvers -- admittedly this may be less of a win.)

\section{Encoding as a quantified Boolean formula}

One advantage of looking for bounds on NAND gate circuits
(as opposed to, say, circuits with AND, OR, and NOT gates,
or arbitrary Boolean functions) is that the gates are all
the same kind. The circuit is defined {\em only} by its
connectivity.

This means that we can encode a circuit
using a Boolean variable for each wire which might be
present. Specifically, we can encode an $m$-input circuit
made of $g$ NAND gates using $mg$ bits (one per input-gate
wire), plus $g \choose 2$ bits (one per gate-gate wire).
We also have one variable per input wire (edge), and can code up
a formula for ``has a triangle.''
To code up the formula ``there is a circuit which works'', we
have to universally quantify over the inputs (after all, the
circuit has to work on all inputs). This causes a
blowup in the formula size.

When I ran this, with four vertices and five gates, it
fairly quickly found a working circuit. 
(I didn't actually print out the solution for $n=4$, with
five gates, so it could be incorrect. Given the small numbers
involved, I'm not planning on bothering with this.)
For five vertices, it ruled out a circuit with five gates.
I tried larger numbers of gates (six or seven, I don't recall
which, but definitely less than the known lower bound of eleven
gates), and it just allocated memory until it crashed
my machine (a Thinkpad X200s with 8gb memory.)

\subsection{Forcing wires to be sorted}

I also tried adding a constraint that the rows of
the connectivity matrix are in lexicographic order.
We can do this without loss of generality. Proof sketch:
pick an arbitrary order for the input wires. For all gates
which only have front-level inputs, write their inputs as
a bit-vector, find the lexicographically first, and call it
$g_1$. Then find $g_2$ by only considering front-level inputs,
and wires from $g_1$ (treating it as the most significant bit.)
Repeat until you've added all the gates.
This defines a unique ordering of gates, such that the adjacency
matrix of all wires is lexicographically sorted.

This may have helped a bit, but not much (data not shown; I
look at the effect of this more carefully below.)

\section{Approximate triangle-finding circuits}

In the previous attempt, we quantified over all the possible inputs. This meant that the notion of
whether there was a triangle was part of the formula. As in Razborov's monotone circuit bound \cite{Razborov85lowerbounds}, we
can also approximately specify how the circuit should work.
MAX-CLIQUE, at least, is
hard to approximate, unless $P=NP$ \cite{hastad_clique_1999}, so this
may be enough to specify the formula.

This approach is reminiscent of machine learning: we are asking for a ``simple'' circuit which explains some examples. At first,
I used the $n \choose 3$ cases which have one triangle (and zeros elsewhere) as
positive examples. Following Razborov's monotone circuit bound \cite{Razborov85lowerbounds}, 
I used complete bipartite graphs (``CBIPs'') as negative examples.

This small number of examples was enough to show that, with four vertices,
at least five gates were needed. However, with five vertices, there were
circuits which distinguished those test cases, but had fewer than ${5 \choose 2} + 1$ gates. Therefore, I added test cases which were random graphs,
and added a constraint that the circuit would output 0 or 1 (according
to whether the graph contained a triangle.)

\section{Results}

For a small set of tiny problems, the following table shows whether the problem was satisfiable
(and there is a circuit with that many gates that is correct, at least given the number of
sample inputs given). Also shown is the runtime, on a
lightly-loaded X200s laptop. (Where ``satisfiable?'' is -, I stopped the program by hand.)

\csvautotabular{runtimes.csv}

\section{Conclusions}

This approach didn't improve the lower bounds. However, it was
less memory-intensive than using BDDs. It may be a useful source
of ``likely to be unsatisfiable'' SAT instances.
Forcing the wires to be sorted didn't help much.

\subsection{Future work}

Boiling the problem down to propositional logic presumably loses a lot of the inherent
symmetry in the problem. However, fully automated SAT solvers are arguably more developed
than fully automated first- or higher-order theorem provers.

Rather than using random graphs as training data, it might be possible to choose those
more systematically. Possibly graphs with multiple triangles would be good positive examples.
Or, perhaps two-edge paths (which are triangles with an edge removed) would be good negative
examples.

\bibliography{references}
\bibliographystyle{plain}

\end{document}

